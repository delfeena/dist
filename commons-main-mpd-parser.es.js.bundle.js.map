{"version":3,"file":"commons-main-mpd-parser.es.js.bundle.js","mappings":"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","sources":["webpack://Filmcave/./node_modules/mpd-parser/dist/mpd-parser.es.js"],"sourcesContent":["/*! @name mpd-parser @version 0.22.1 @license Apache-2.0 */\nimport resolveUrl from '@videojs/vhs-utils/es/resolve-url';\nimport window from 'global/window';\nimport { forEachMediaGroup } from '@videojs/vhs-utils/es/media-groups';\nimport decodeB64ToUint8Array from '@videojs/vhs-utils/es/decode-b64-to-uint8-array';\nimport { DOMParser } from '@xmldom/xmldom';\n\nvar version = \"0.22.1\";\n\nvar isObject = function isObject(obj) {\n  return !!obj && typeof obj === 'object';\n};\n\nvar merge = function merge() {\n  for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {\n    objects[_key] = arguments[_key];\n  }\n\n  return objects.reduce(function (result, source) {\n    if (typeof source !== 'object') {\n      return result;\n    }\n\n    Object.keys(source).forEach(function (key) {\n      if (Array.isArray(result[key]) && Array.isArray(source[key])) {\n        result[key] = result[key].concat(source[key]);\n      } else if (isObject(result[key]) && isObject(source[key])) {\n        result[key] = merge(result[key], source[key]);\n      } else {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }, {});\n};\nvar values = function values(o) {\n  return Object.keys(o).map(function (k) {\n    return o[k];\n  });\n};\n\nvar range = function range(start, end) {\n  var result = [];\n\n  for (var i = start; i < end; i++) {\n    result.push(i);\n  }\n\n  return result;\n};\nvar flatten = function flatten(lists) {\n  return lists.reduce(function (x, y) {\n    return x.concat(y);\n  }, []);\n};\nvar from = function from(list) {\n  if (!list.length) {\n    return [];\n  }\n\n  var result = [];\n\n  for (var i = 0; i < list.length; i++) {\n    result.push(list[i]);\n  }\n\n  return result;\n};\nvar findIndexes = function findIndexes(l, key) {\n  return l.reduce(function (a, e, i) {\n    if (e[key]) {\n      a.push(i);\n    }\n\n    return a;\n  }, []);\n};\n/**\n * Returns the first index that satisfies the matching function, or -1 if not found.\n *\n * Only necessary because of IE11 support.\n *\n * @param {Array} list - the list to search through\n * @param {Function} matchingFunction - the matching function\n *\n * @return {number} the matching index or -1 if not found\n */\n\nvar findIndex = function findIndex(list, matchingFunction) {\n  for (var i = 0; i < list.length; i++) {\n    if (matchingFunction(list[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Returns a union of the included lists provided each element can be identified by a key.\n *\n * @param {Array} list - list of lists to get the union of\n * @param {Function} keyFunction - the function to use as a key for each element\n *\n * @return {Array} the union of the arrays\n */\n\nvar union = function union(lists, keyFunction) {\n  return values(lists.reduce(function (acc, list) {\n    list.forEach(function (el) {\n      acc[keyFunction(el)] = el;\n    });\n    return acc;\n  }, {}));\n};\n\nvar errors = {\n  INVALID_NUMBER_OF_PERIOD: 'INVALID_NUMBER_OF_PERIOD',\n  DASH_EMPTY_MANIFEST: 'DASH_EMPTY_MANIFEST',\n  DASH_INVALID_XML: 'DASH_INVALID_XML',\n  NO_BASE_URL: 'NO_BASE_URL',\n  MISSING_SEGMENT_INFORMATION: 'MISSING_SEGMENT_INFORMATION',\n  SEGMENT_TIME_UNSPECIFIED: 'SEGMENT_TIME_UNSPECIFIED',\n  UNSUPPORTED_UTC_TIMING_SCHEME: 'UNSUPPORTED_UTC_TIMING_SCHEME'\n};\n\n/**\n * @typedef {Object} SingleUri\n * @property {string} uri - relative location of segment\n * @property {string} resolvedUri - resolved location of segment\n * @property {Object} byterange - Object containing information on how to make byte range\n *   requests following byte-range-spec per RFC2616.\n * @property {String} byterange.length - length of range request\n * @property {String} byterange.offset - byte offset of range request\n *\n * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35.1\n */\n\n/**\n * Converts a URLType node (5.3.9.2.3 Table 13) to a segment object\n * that conforms to how m3u8-parser is structured\n *\n * @see https://github.com/videojs/m3u8-parser\n *\n * @param {string} baseUrl - baseUrl provided by <BaseUrl> nodes\n * @param {string} source - source url for segment\n * @param {string} range - optional range used for range calls,\n *   follows  RFC 2616, Clause 14.35.1\n * @return {SingleUri} full segment information transformed into a format similar\n *   to m3u8-parser\n */\n\nvar urlTypeToSegment = function urlTypeToSegment(_ref) {\n  var _ref$baseUrl = _ref.baseUrl,\n      baseUrl = _ref$baseUrl === void 0 ? '' : _ref$baseUrl,\n      _ref$source = _ref.source,\n      source = _ref$source === void 0 ? '' : _ref$source,\n      _ref$range = _ref.range,\n      range = _ref$range === void 0 ? '' : _ref$range,\n      _ref$indexRange = _ref.indexRange,\n      indexRange = _ref$indexRange === void 0 ? '' : _ref$indexRange;\n  var segment = {\n    uri: source,\n    resolvedUri: resolveUrl(baseUrl || '', source)\n  };\n\n  if (range || indexRange) {\n    var rangeStr = range ? range : indexRange;\n    var ranges = rangeStr.split('-'); // default to parsing this as a BigInt if possible\n\n    var startRange = window.BigInt ? window.BigInt(ranges[0]) : parseInt(ranges[0], 10);\n    var endRange = window.BigInt ? window.BigInt(ranges[1]) : parseInt(ranges[1], 10); // convert back to a number if less than MAX_SAFE_INTEGER\n\n    if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === 'bigint') {\n      startRange = Number(startRange);\n    }\n\n    if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === 'bigint') {\n      endRange = Number(endRange);\n    }\n\n    var length;\n\n    if (typeof endRange === 'bigint' || typeof startRange === 'bigint') {\n      length = window.BigInt(endRange) - window.BigInt(startRange) + window.BigInt(1);\n    } else {\n      length = endRange - startRange + 1;\n    }\n\n    if (typeof length === 'bigint' && length < Number.MAX_SAFE_INTEGER) {\n      length = Number(length);\n    } // byterange should be inclusive according to\n    // RFC 2616, Clause 14.35.1\n\n\n    segment.byterange = {\n      length: length,\n      offset: startRange\n    };\n  }\n\n  return segment;\n};\nvar byteRangeToString = function byteRangeToString(byterange) {\n  // `endRange` is one less than `offset + length` because the HTTP range\n  // header uses inclusive ranges\n  var endRange;\n\n  if (typeof byterange.offset === 'bigint' || typeof byterange.length === 'bigint') {\n    endRange = window.BigInt(byterange.offset) + window.BigInt(byterange.length) - window.BigInt(1);\n  } else {\n    endRange = byterange.offset + byterange.length - 1;\n  }\n\n  return byterange.offset + \"-\" + endRange;\n};\n\n/**\n * parse the end number attribue that can be a string\n * number, or undefined.\n *\n * @param {string|number|undefined} endNumber\n *        The end number attribute.\n *\n * @return {number|null}\n *          The result of parsing the end number.\n */\n\nvar parseEndNumber = function parseEndNumber(endNumber) {\n  if (endNumber && typeof endNumber !== 'number') {\n    endNumber = parseInt(endNumber, 10);\n  }\n\n  if (isNaN(endNumber)) {\n    return null;\n  }\n\n  return endNumber;\n};\n/**\n * Functions for calculating the range of available segments in static and dynamic\n * manifests.\n */\n\n\nvar segmentRange = {\n  /**\n   * Returns the entire range of available segments for a static MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  static: function _static(attributes) {\n    var duration = attributes.duration,\n        _attributes$timescale = attributes.timescale,\n        timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n        sourceDuration = attributes.sourceDuration,\n        periodDuration = attributes.periodDuration;\n    var endNumber = parseEndNumber(attributes.endNumber);\n    var segmentDuration = duration / timescale;\n\n    if (typeof endNumber === 'number') {\n      return {\n        start: 0,\n        end: endNumber\n      };\n    }\n\n    if (typeof periodDuration === 'number') {\n      return {\n        start: 0,\n        end: periodDuration / segmentDuration\n      };\n    }\n\n    return {\n      start: 0,\n      end: sourceDuration / segmentDuration\n    };\n  },\n\n  /**\n   * Returns the current live window range of available segments for a dynamic MPD\n   *\n   * @param {Object} attributes\n   *        Inheritied MPD attributes\n   * @return {{ start: number, end: number }}\n   *         The start and end numbers for available segments\n   */\n  dynamic: function dynamic(attributes) {\n    var NOW = attributes.NOW,\n        clientOffset = attributes.clientOffset,\n        availabilityStartTime = attributes.availabilityStartTime,\n        _attributes$timescale2 = attributes.timescale,\n        timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n        duration = attributes.duration,\n        _attributes$periodSta = attributes.periodStart,\n        periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta,\n        _attributes$minimumUp = attributes.minimumUpdatePeriod,\n        minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp,\n        _attributes$timeShift = attributes.timeShiftBufferDepth,\n        timeShiftBufferDepth = _attributes$timeShift === void 0 ? Infinity : _attributes$timeShift;\n    var endNumber = parseEndNumber(attributes.endNumber); // clientOffset is passed in at the top level of mpd-parser and is an offset calculated\n    // after retrieving UTC server time.\n\n    var now = (NOW + clientOffset) / 1000; // WC stands for Wall Clock.\n    // Convert the period start time to EPOCH.\n\n    var periodStartWC = availabilityStartTime + periodStart; // Period end in EPOCH is manifest's retrieval time + time until next update.\n\n    var periodEndWC = now + minimumUpdatePeriod;\n    var periodDuration = periodEndWC - periodStartWC;\n    var segmentCount = Math.ceil(periodDuration * timescale / duration);\n    var availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);\n    var availableEnd = Math.floor((now - periodStartWC) * timescale / duration);\n    return {\n      start: Math.max(0, availableStart),\n      end: typeof endNumber === 'number' ? endNumber : Math.min(segmentCount, availableEnd)\n    };\n  }\n};\n/**\n * Maps a range of numbers to objects with information needed to build the corresponding\n * segment list\n *\n * @name toSegmentsCallback\n * @function\n * @param {number} number\n *        Number of the segment\n * @param {number} index\n *        Index of the number in the range list\n * @return {{ number: Number, duration: Number, timeline: Number, time: Number }}\n *         Object with segment timing and duration info\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping a range of numbers to\n * information needed to build the segment list.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {toSegmentsCallback}\n *         Callback map function\n */\n\nvar toSegments = function toSegments(attributes) {\n  return function (number) {\n    var duration = attributes.duration,\n        _attributes$timescale3 = attributes.timescale,\n        timescale = _attributes$timescale3 === void 0 ? 1 : _attributes$timescale3,\n        periodStart = attributes.periodStart,\n        _attributes$startNumb = attributes.startNumber,\n        startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb;\n    return {\n      number: startNumber + number,\n      duration: duration / timescale,\n      timeline: periodStart,\n      time: number * duration\n    };\n  };\n};\n/**\n * Returns a list of objects containing segment timing and duration info used for\n * building the list of segments. This uses the @duration attribute specified\n * in the MPD manifest to derive the range of segments.\n *\n * @param {Object} attributes\n *        Inherited MPD attributes\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nvar parseByDuration = function parseByDuration(attributes) {\n  var type = attributes.type,\n      duration = attributes.duration,\n      _attributes$timescale4 = attributes.timescale,\n      timescale = _attributes$timescale4 === void 0 ? 1 : _attributes$timescale4,\n      periodDuration = attributes.periodDuration,\n      sourceDuration = attributes.sourceDuration;\n\n  var _segmentRange$type = segmentRange[type](attributes),\n      start = _segmentRange$type.start,\n      end = _segmentRange$type.end;\n\n  var segments = range(start, end).map(toSegments(attributes));\n\n  if (type === 'static') {\n    var index = segments.length - 1; // section is either a period or the full source\n\n    var sectionDuration = typeof periodDuration === 'number' ? periodDuration : sourceDuration; // final segment may be less than full segment duration\n\n    segments[index].duration = sectionDuration - duration / timescale * index;\n  }\n\n  return segments;\n};\n\n/**\n * Translates SegmentBase into a set of segments.\n * (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @return {Object.<Array>} list of segments\n */\n\nvar segmentsFromBase = function segmentsFromBase(attributes) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$indexRang = attributes.indexRange,\n      indexRange = _attributes$indexRang === void 0 ? '' : _attributes$indexRang,\n      periodStart = attributes.periodStart,\n      presentationTime = attributes.presentationTime,\n      _attributes$number = attributes.number,\n      number = _attributes$number === void 0 ? 0 : _attributes$number,\n      duration = attributes.duration; // base url is required for SegmentBase to work, per spec (Section 5.3.9.2.1)\n\n  if (!baseUrl) {\n    throw new Error(errors.NO_BASE_URL);\n  }\n\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: baseUrl,\n    indexRange: indexRange\n  });\n  segment.map = initSegment; // If there is a duration, use it, otherwise use the given duration of the source\n  // (since SegmentBase is only for one total segment)\n\n  if (duration) {\n    var segmentTimeInfo = parseByDuration(attributes);\n\n    if (segmentTimeInfo.length) {\n      segment.duration = segmentTimeInfo[0].duration;\n      segment.timeline = segmentTimeInfo[0].timeline;\n    }\n  } else if (sourceDuration) {\n    segment.duration = sourceDuration;\n    segment.timeline = periodStart;\n  } // If presentation time is provided, these segments are being generated by SIDX\n  // references, and should use the time provided. For the general case of SegmentBase,\n  // there should only be one segment in the period, so its presentation time is the same\n  // as its period start.\n\n\n  segment.presentationTime = presentationTime || periodStart;\n  segment.number = number;\n  return [segment];\n};\n/**\n * Given a playlist, a sidx box, and a baseUrl, update the segment list of the playlist\n * according to the sidx information given.\n *\n * playlist.sidx has metadadata about the sidx where-as the sidx param\n * is the parsed sidx box itself.\n *\n * @param {Object} playlist the playlist to update the sidx information for\n * @param {Object} sidx the parsed sidx box\n * @return {Object} the playlist object with the updated sidx information\n */\n\nvar addSidxSegmentsToPlaylist$1 = function addSidxSegmentsToPlaylist(playlist, sidx, baseUrl) {\n  // Retain init segment information\n  var initSegment = playlist.sidx.map ? playlist.sidx.map : null; // Retain source duration from initial main manifest parsing\n\n  var sourceDuration = playlist.sidx.duration; // Retain source timeline\n\n  var timeline = playlist.timeline || 0;\n  var sidxByteRange = playlist.sidx.byterange;\n  var sidxEnd = sidxByteRange.offset + sidxByteRange.length; // Retain timescale of the parsed sidx\n\n  var timescale = sidx.timescale; // referenceType 1 refers to other sidx boxes\n\n  var mediaReferences = sidx.references.filter(function (r) {\n    return r.referenceType !== 1;\n  });\n  var segments = [];\n  var type = playlist.endList ? 'static' : 'dynamic';\n  var periodStart = playlist.sidx.timeline;\n  var presentationTime = periodStart;\n  var number = playlist.mediaSequence || 0; // firstOffset is the offset from the end of the sidx box\n\n  var startIndex; // eslint-disable-next-line\n\n  if (typeof sidx.firstOffset === 'bigint') {\n    startIndex = window.BigInt(sidxEnd) + sidx.firstOffset;\n  } else {\n    startIndex = sidxEnd + sidx.firstOffset;\n  }\n\n  for (var i = 0; i < mediaReferences.length; i++) {\n    var reference = sidx.references[i]; // size of the referenced (sub)segment\n\n    var size = reference.referencedSize; // duration of the referenced (sub)segment, in  the  timescale\n    // this will be converted to seconds when generating segments\n\n    var duration = reference.subsegmentDuration; // should be an inclusive range\n\n    var endIndex = void 0; // eslint-disable-next-line\n\n    if (typeof startIndex === 'bigint') {\n      endIndex = startIndex + window.BigInt(size) - window.BigInt(1);\n    } else {\n      endIndex = startIndex + size - 1;\n    }\n\n    var indexRange = startIndex + \"-\" + endIndex;\n    var attributes = {\n      baseUrl: baseUrl,\n      timescale: timescale,\n      timeline: timeline,\n      periodStart: periodStart,\n      presentationTime: presentationTime,\n      number: number,\n      duration: duration,\n      sourceDuration: sourceDuration,\n      indexRange: indexRange,\n      type: type\n    };\n    var segment = segmentsFromBase(attributes)[0];\n\n    if (initSegment) {\n      segment.map = initSegment;\n    }\n\n    segments.push(segment);\n\n    if (typeof startIndex === 'bigint') {\n      startIndex += window.BigInt(size);\n    } else {\n      startIndex += size;\n    }\n\n    presentationTime += duration / timescale;\n    number++;\n  }\n\n  playlist.segments = segments;\n  return playlist;\n};\n\nvar SUPPORTED_MEDIA_TYPES = ['AUDIO', 'SUBTITLES']; // allow one 60fps frame as leniency (arbitrarily chosen)\n\nvar TIME_FUDGE = 1 / 60;\n/**\n * Given a list of timelineStarts, combines, dedupes, and sorts them.\n *\n * @param {TimelineStart[]} timelineStarts - list of timeline starts\n *\n * @return {TimelineStart[]} the combined and deduped timeline starts\n */\n\nvar getUniqueTimelineStarts = function getUniqueTimelineStarts(timelineStarts) {\n  return union(timelineStarts, function (_ref) {\n    var timeline = _ref.timeline;\n    return timeline;\n  }).sort(function (a, b) {\n    return a.timeline > b.timeline ? 1 : -1;\n  });\n};\n/**\n * Finds the playlist with the matching NAME attribute.\n *\n * @param {Array} playlists - playlists to search through\n * @param {string} name - the NAME attribute to search for\n *\n * @return {Object|null} the matching playlist object, or null\n */\n\nvar findPlaylistWithName = function findPlaylistWithName(playlists, name) {\n  for (var i = 0; i < playlists.length; i++) {\n    if (playlists[i].attributes.NAME === name) {\n      return playlists[i];\n    }\n  }\n\n  return null;\n};\n/**\n * Gets a flattened array of media group playlists.\n *\n * @param {Object} manifest - the main manifest object\n *\n * @return {Array} the media group playlists\n */\n\nvar getMediaGroupPlaylists = function getMediaGroupPlaylists(manifest) {\n  var mediaGroupPlaylists = [];\n  forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, function (properties, type, group, label) {\n    mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);\n  });\n  return mediaGroupPlaylists;\n};\n/**\n * Updates the playlist's media sequence numbers.\n *\n * @param {Object} config - options object\n * @param {Object} config.playlist - the playlist to update\n * @param {number} config.mediaSequence - the mediaSequence number to start with\n */\n\nvar updateMediaSequenceForPlaylist = function updateMediaSequenceForPlaylist(_ref2) {\n  var playlist = _ref2.playlist,\n      mediaSequence = _ref2.mediaSequence;\n  playlist.mediaSequence = mediaSequence;\n  playlist.segments.forEach(function (segment, index) {\n    segment.number = playlist.mediaSequence + index;\n  });\n};\n/**\n * Updates the media and discontinuity sequence numbers of newPlaylists given oldPlaylists\n * and a complete list of timeline starts.\n *\n * If no matching playlist is found, only the discontinuity sequence number of the playlist\n * will be updated.\n *\n * Since early available timelines are not supported, at least one segment must be present.\n *\n * @param {Object} config - options object\n * @param {Object[]} oldPlaylists - the old playlists to use as a reference\n * @param {Object[]} newPlaylists - the new playlists to update\n * @param {Object} timelineStarts - all timelineStarts seen in the stream to this point\n */\n\nvar updateSequenceNumbers = function updateSequenceNumbers(_ref3) {\n  var oldPlaylists = _ref3.oldPlaylists,\n      newPlaylists = _ref3.newPlaylists,\n      timelineStarts = _ref3.timelineStarts;\n  newPlaylists.forEach(function (playlist) {\n    playlist.discontinuitySequence = findIndex(timelineStarts, function (_ref4) {\n      var timeline = _ref4.timeline;\n      return timeline === playlist.timeline;\n    }); // Playlists NAMEs come from DASH Representation IDs, which are mandatory\n    // (see ISO_23009-1-2012 5.3.5.2).\n    //\n    // If the same Representation existed in a prior Period, it will retain the same NAME.\n\n    var oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);\n\n    if (!oldPlaylist) {\n      // Since this is a new playlist, the media sequence values can start from 0 without\n      // consequence.\n      return;\n    } // TODO better support for live SIDX\n    //\n    // As of this writing, mpd-parser does not support multiperiod SIDX (in live or VOD).\n    // This is evident by a playlist only having a single SIDX reference. In a multiperiod\n    // playlist there would need to be multiple SIDX references. In addition, live SIDX is\n    // not supported when the SIDX properties change on refreshes.\n    //\n    // In the future, if support needs to be added, the merging logic here can be called\n    // after SIDX references are resolved. For now, exit early to prevent exceptions being\n    // thrown due to undefined references.\n\n\n    if (playlist.sidx) {\n      return;\n    } // Since we don't yet support early available timelines, we don't need to support\n    // playlists with no segments.\n\n\n    var firstNewSegment = playlist.segments[0];\n    var oldMatchingSegmentIndex = findIndex(oldPlaylist.segments, function (oldSegment) {\n      return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;\n    }); // No matching segment from the old playlist means the entire playlist was refreshed.\n    // In this case the media sequence should account for this update, and the new segments\n    // should be marked as discontinuous from the prior content, since the last prior\n    // timeline was removed.\n\n    if (oldMatchingSegmentIndex === -1) {\n      updateMediaSequenceForPlaylist({\n        playlist: playlist,\n        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length\n      });\n      playlist.segments[0].discontinuity = true;\n      playlist.discontinuityStarts.unshift(0); // No matching segment does not necessarily mean there's missing content.\n      //\n      // If the new playlist's timeline is the same as the last seen segment's timeline,\n      // then a discontinuity can be added to identify that there's potentially missing\n      // content. If there's no missing content, the discontinuity should still be rather\n      // harmless. It's possible that if segment durations are accurate enough, that the\n      // existence of a gap can be determined using the presentation times and durations,\n      // but if the segment timing info is off, it may introduce more problems than simply\n      // adding the discontinuity.\n      //\n      // If the new playlist's timeline is different from the last seen segment's timeline,\n      // then a discontinuity can be added to identify that this is the first seen segment\n      // of a new timeline. However, the logic at the start of this function that\n      // determined the disconinuity sequence by timeline index is now off by one (the\n      // discontinuity of the newest timeline hasn't yet fallen off the manifest...since\n      // we added it), so the disconinuity sequence must be decremented.\n      //\n      // A period may also have a duration of zero, so the case of no segments is handled\n      // here even though we don't yet support early available periods.\n\n      if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) {\n        playlist.discontinuitySequence--;\n      }\n\n      return;\n    } // If the first segment matched with a prior segment on a discontinuity (it's matching\n    // on the first segment of a period), then the discontinuitySequence shouldn't be the\n    // timeline's matching one, but instead should be the one prior, and the first segment\n    // of the new manifest should be marked with a discontinuity.\n    //\n    // The reason for this special case is that discontinuity sequence shows how many\n    // discontinuities have fallen off of the playlist, and discontinuities are marked on\n    // the first segment of a new \"timeline.\" Because of this, while DASH will retain that\n    // Period while the \"timeline\" exists, HLS keeps track of it via the discontinuity\n    // sequence, and that first segment is an indicator, but can be removed before that\n    // timeline is gone.\n\n\n    var oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];\n\n    if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {\n      firstNewSegment.discontinuity = true;\n      playlist.discontinuityStarts.unshift(0);\n      playlist.discontinuitySequence--;\n    }\n\n    updateMediaSequenceForPlaylist({\n      playlist: playlist,\n      mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number\n    });\n  });\n};\n/**\n * Given an old parsed manifest object and a new parsed manifest object, updates the\n * sequence and timing values within the new manifest to ensure that it lines up with the\n * old.\n *\n * @param {Array} oldManifest - the old main manifest object\n * @param {Array} newManifest - the new main manifest object\n *\n * @return {Object} the updated new manifest object\n */\n\nvar positionManifestOnTimeline = function positionManifestOnTimeline(_ref5) {\n  var oldManifest = _ref5.oldManifest,\n      newManifest = _ref5.newManifest;\n  // Starting from v4.1.2 of the IOP, section 4.4.3.3 states:\n  //\n  // \"MPD@availabilityStartTime and Period@start shall not be changed over MPD updates.\"\n  //\n  // This was added from https://github.com/Dash-Industry-Forum/DASH-IF-IOP/issues/160\n  //\n  // Because of this change, and the difficulty of supporting periods with changing start\n  // times, periods with changing start times are not supported. This makes the logic much\n  // simpler, since periods with the same start time can be considerred the same period\n  // across refreshes.\n  //\n  // To give an example as to the difficulty of handling periods where the start time may\n  // change, if a single period manifest is refreshed with another manifest with a single\n  // period, and both the start and end times are increased, then the only way to determine\n  // if it's a new period or an old one that has changed is to look through the segments of\n  // each playlist and determine the presentation time bounds to find a match. In addition,\n  // if the period start changed to exceed the old period end, then there would be no\n  // match, and it would not be possible to determine whether the refreshed period is a new\n  // one or the old one.\n  var oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));\n  var newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest)); // Save all seen timelineStarts to the new manifest. Although this potentially means that\n  // there's a \"memory leak\" in that it will never stop growing, in reality, only a couple\n  // of properties are saved for each seen Period. Even long running live streams won't\n  // generate too many Periods, unless the stream is watched for decades. In the future,\n  // this can be optimized by mapping to discontinuity sequence numbers for each timeline,\n  // but it may not become an issue, and the additional info can be useful for debugging.\n\n  newManifest.timelineStarts = getUniqueTimelineStarts([oldManifest.timelineStarts, newManifest.timelineStarts]);\n  updateSequenceNumbers({\n    oldPlaylists: oldPlaylists,\n    newPlaylists: newPlaylists,\n    timelineStarts: newManifest.timelineStarts\n  });\n  return newManifest;\n};\n\nvar generateSidxKey = function generateSidxKey(sidx) {\n  return sidx && sidx.uri + '-' + byteRangeToString(sidx.byterange);\n};\n\nvar mergeDiscontiguousPlaylists = function mergeDiscontiguousPlaylists(playlists) {\n  var mergedPlaylists = values(playlists.reduce(function (acc, playlist) {\n    // assuming playlist IDs are the same across periods\n    // TODO: handle multiperiod where representation sets are not the same\n    // across periods\n    var name = playlist.attributes.id + (playlist.attributes.lang || '');\n\n    if (!acc[name]) {\n      // First Period\n      acc[name] = playlist;\n      acc[name].attributes.timelineStarts = [];\n    } else {\n      // Subsequent Periods\n      if (playlist.segments) {\n        var _acc$name$segments;\n\n        // first segment of subsequent periods signal a discontinuity\n        if (playlist.segments[0]) {\n          playlist.segments[0].discontinuity = true;\n        }\n\n        (_acc$name$segments = acc[name].segments).push.apply(_acc$name$segments, playlist.segments);\n      } // bubble up contentProtection, this assumes all DRM content\n      // has the same contentProtection\n\n\n      if (playlist.attributes.contentProtection) {\n        acc[name].attributes.contentProtection = playlist.attributes.contentProtection;\n      }\n    }\n\n    acc[name].attributes.timelineStarts.push({\n      // Although they represent the same number, it's important to have both to make it\n      // compatible with HLS potentially having a similar attribute.\n      start: playlist.attributes.periodStart,\n      timeline: playlist.attributes.periodStart\n    });\n    return acc;\n  }, {}));\n  return mergedPlaylists.map(function (playlist) {\n    playlist.discontinuityStarts = findIndexes(playlist.segments || [], 'discontinuity');\n    return playlist;\n  });\n};\n\nvar addSidxSegmentsToPlaylist = function addSidxSegmentsToPlaylist(playlist, sidxMapping) {\n  var sidxKey = generateSidxKey(playlist.sidx);\n  var sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;\n\n  if (sidxMatch) {\n    addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);\n  }\n\n  return playlist;\n};\nvar addSidxSegmentsToPlaylists = function addSidxSegmentsToPlaylists(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  if (!Object.keys(sidxMapping).length) {\n    return playlists;\n  }\n\n  for (var i in playlists) {\n    playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);\n  }\n\n  return playlists;\n};\nvar formatAudioPlaylist = function formatAudioPlaylist(_ref, isAudioOnly) {\n  var _attributes;\n\n  var attributes = _ref.attributes,\n      segments = _ref.segments,\n      sidx = _ref.sidx,\n      mediaSequence = _ref.mediaSequence,\n      discontinuitySequence = _ref.discontinuitySequence,\n      discontinuityStarts = _ref.discontinuityStarts;\n  var playlist = {\n    attributes: (_attributes = {\n      NAME: attributes.id,\n      BANDWIDTH: attributes.bandwidth,\n      CODECS: attributes.codecs\n    }, _attributes['PROGRAM-ID'] = 1, _attributes),\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    discontinuitySequence: discontinuitySequence,\n    discontinuityStarts: discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    mediaSequence: mediaSequence,\n    segments: segments\n  };\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  if (isAudioOnly) {\n    playlist.attributes.AUDIO = 'audio';\n    playlist.attributes.SUBTITLES = 'subs';\n  }\n\n  return playlist;\n};\nvar formatVttPlaylist = function formatVttPlaylist(_ref2) {\n  var _m3u8Attributes;\n\n  var attributes = _ref2.attributes,\n      segments = _ref2.segments,\n      mediaSequence = _ref2.mediaSequence,\n      discontinuityStarts = _ref2.discontinuityStarts,\n      discontinuitySequence = _ref2.discontinuitySequence;\n\n  if (typeof segments === 'undefined') {\n    // vtt tracks may use single file in BaseURL\n    segments = [{\n      uri: attributes.baseUrl,\n      timeline: attributes.periodStart,\n      resolvedUri: attributes.baseUrl || '',\n      duration: attributes.sourceDuration,\n      number: 0\n    }]; // targetDuration should be the same duration as the only segment\n\n    attributes.duration = attributes.sourceDuration;\n  }\n\n  var m3u8Attributes = (_m3u8Attributes = {\n    NAME: attributes.id,\n    BANDWIDTH: attributes.bandwidth\n  }, _m3u8Attributes['PROGRAM-ID'] = 1, _m3u8Attributes);\n\n  if (attributes.codecs) {\n    m3u8Attributes.CODECS = attributes.codecs;\n  }\n\n  return {\n    attributes: m3u8Attributes,\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: attributes.baseUrl || '',\n    targetDuration: attributes.duration,\n    timelineStarts: attributes.timelineStarts,\n    discontinuityStarts: discontinuityStarts,\n    discontinuitySequence: discontinuitySequence,\n    mediaSequence: mediaSequence,\n    segments: segments\n  };\n};\nvar organizeAudioPlaylists = function organizeAudioPlaylists(playlists, sidxMapping, isAudioOnly) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  if (isAudioOnly === void 0) {\n    isAudioOnly = false;\n  }\n\n  var mainPlaylist;\n  var formattedPlaylists = playlists.reduce(function (a, playlist) {\n    var role = playlist.attributes.role && playlist.attributes.role.value || '';\n    var language = playlist.attributes.lang || '';\n    var label = playlist.attributes.label || 'main';\n\n    if (language && !playlist.attributes.label) {\n      var roleLabel = role ? \" (\" + role + \")\" : '';\n      label = \"\" + playlist.attributes.lang + roleLabel;\n    }\n\n    if (!a[label]) {\n      a[label] = {\n        language: language,\n        autoselect: true,\n        default: role === 'main',\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    var formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);\n    a[label].playlists.push(formatted);\n\n    if (typeof mainPlaylist === 'undefined' && role === 'main') {\n      mainPlaylist = playlist;\n      mainPlaylist.default = true;\n    }\n\n    return a;\n  }, {}); // if no playlists have role \"main\", mark the first as main\n\n  if (!mainPlaylist) {\n    var firstLabel = Object.keys(formattedPlaylists)[0];\n    formattedPlaylists[firstLabel].default = true;\n  }\n\n  return formattedPlaylists;\n};\nvar organizeVttPlaylists = function organizeVttPlaylists(playlists, sidxMapping) {\n  if (sidxMapping === void 0) {\n    sidxMapping = {};\n  }\n\n  return playlists.reduce(function (a, playlist) {\n    var label = playlist.attributes.lang || 'text';\n\n    if (!a[label]) {\n      a[label] = {\n        language: label,\n        default: false,\n        autoselect: false,\n        playlists: [],\n        uri: ''\n      };\n    }\n\n    a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));\n    return a;\n  }, {});\n};\n\nvar organizeCaptionServices = function organizeCaptionServices(captionServices) {\n  return captionServices.reduce(function (svcObj, svc) {\n    if (!svc) {\n      return svcObj;\n    }\n\n    svc.forEach(function (service) {\n      var channel = service.channel,\n          language = service.language;\n      svcObj[language] = {\n        autoselect: false,\n        default: false,\n        instreamId: channel,\n        language: language\n      };\n\n      if (service.hasOwnProperty('aspectRatio')) {\n        svcObj[language].aspectRatio = service.aspectRatio;\n      }\n\n      if (service.hasOwnProperty('easyReader')) {\n        svcObj[language].easyReader = service.easyReader;\n      }\n\n      if (service.hasOwnProperty('3D')) {\n        svcObj[language]['3D'] = service['3D'];\n      }\n    });\n    return svcObj;\n  }, {});\n};\n\nvar formatVideoPlaylist = function formatVideoPlaylist(_ref3) {\n  var _attributes2;\n\n  var attributes = _ref3.attributes,\n      segments = _ref3.segments,\n      sidx = _ref3.sidx,\n      discontinuityStarts = _ref3.discontinuityStarts;\n  var playlist = {\n    attributes: (_attributes2 = {\n      NAME: attributes.id,\n      AUDIO: 'audio',\n      SUBTITLES: 'subs',\n      RESOLUTION: {\n        width: attributes.width,\n        height: attributes.height\n      },\n      CODECS: attributes.codecs,\n      BANDWIDTH: attributes.bandwidth\n    }, _attributes2['PROGRAM-ID'] = 1, _attributes2),\n    uri: '',\n    endList: attributes.type === 'static',\n    timeline: attributes.periodStart,\n    resolvedUri: '',\n    targetDuration: attributes.duration,\n    discontinuityStarts: discontinuityStarts,\n    timelineStarts: attributes.timelineStarts,\n    segments: segments\n  };\n\n  if (attributes.frameRate) {\n    playlist.attributes['FRAME-RATE'] = attributes.frameRate;\n  }\n\n  if (attributes.contentProtection) {\n    playlist.contentProtection = attributes.contentProtection;\n  }\n\n  if (sidx) {\n    playlist.sidx = sidx;\n  }\n\n  return playlist;\n};\n\nvar videoOnly = function videoOnly(_ref4) {\n  var attributes = _ref4.attributes;\n  return attributes.mimeType === 'video/mp4' || attributes.mimeType === 'video/webm' || attributes.contentType === 'video';\n};\n\nvar audioOnly = function audioOnly(_ref5) {\n  var attributes = _ref5.attributes;\n  return attributes.mimeType === 'audio/mp4' || attributes.mimeType === 'audio/webm' || attributes.contentType === 'audio';\n};\n\nvar vttOnly = function vttOnly(_ref6) {\n  var attributes = _ref6.attributes;\n  return attributes.mimeType === 'text/vtt' || attributes.contentType === 'text';\n};\n/**\n * Contains start and timeline properties denoting a timeline start. For DASH, these will\n * be the same number.\n *\n * @typedef {Object} TimelineStart\n * @property {number} start - the start time of the timeline\n * @property {number} timeline - the timeline number\n */\n\n/**\n * Adds appropriate media and discontinuity sequence values to the segments and playlists.\n *\n * Throughout mpd-parser, the `number` attribute is used in relation to `startNumber`, a\n * DASH specific attribute used in constructing segment URI's from templates. However, from\n * an HLS perspective, the `number` attribute on a segment would be its `mediaSequence`\n * value, which should start at the original media sequence value (or 0) and increment by 1\n * for each segment thereafter. Since DASH's `startNumber` values are independent per\n * period, it doesn't make sense to use it for `number`. Instead, assume everything starts\n * from a 0 mediaSequence value and increment from there.\n *\n * Note that VHS currently doesn't use the `number` property, but it can be helpful for\n * debugging and making sense of the manifest.\n *\n * For live playlists, to account for values increasing in manifests when periods are\n * removed on refreshes, merging logic should be used to update the numbers to their\n * appropriate values (to ensure they're sequential and increasing).\n *\n * @param {Object[]} playlists - the playlists to update\n * @param {TimelineStart[]} timelineStarts - the timeline starts for the manifest\n */\n\n\nvar addMediaSequenceValues = function addMediaSequenceValues(playlists, timelineStarts) {\n  // increment all segments sequentially\n  playlists.forEach(function (playlist) {\n    playlist.mediaSequence = 0;\n    playlist.discontinuitySequence = findIndex(timelineStarts, function (_ref7) {\n      var timeline = _ref7.timeline;\n      return timeline === playlist.timeline;\n    });\n\n    if (!playlist.segments) {\n      return;\n    }\n\n    playlist.segments.forEach(function (segment, index) {\n      segment.number = index;\n    });\n  });\n};\n/**\n * Given a media group object, flattens all playlists within the media group into a single\n * array.\n *\n * @param {Object} mediaGroupObject - the media group object\n *\n * @return {Object[]}\n *         The media group playlists\n */\n\nvar flattenMediaGroupPlaylists = function flattenMediaGroupPlaylists(mediaGroupObject) {\n  if (!mediaGroupObject) {\n    return [];\n  }\n\n  return Object.keys(mediaGroupObject).reduce(function (acc, label) {\n    var labelContents = mediaGroupObject[label];\n    return acc.concat(labelContents.playlists);\n  }, []);\n};\nvar toM3u8 = function toM3u8(_ref8) {\n  var _mediaGroups;\n\n  var dashPlaylists = _ref8.dashPlaylists,\n      locations = _ref8.locations,\n      _ref8$sidxMapping = _ref8.sidxMapping,\n      sidxMapping = _ref8$sidxMapping === void 0 ? {} : _ref8$sidxMapping,\n      previousManifest = _ref8.previousManifest;\n\n  if (!dashPlaylists.length) {\n    return {};\n  } // grab all main manifest attributes\n\n\n  var _dashPlaylists$0$attr = dashPlaylists[0].attributes,\n      duration = _dashPlaylists$0$attr.sourceDuration,\n      type = _dashPlaylists$0$attr.type,\n      suggestedPresentationDelay = _dashPlaylists$0$attr.suggestedPresentationDelay,\n      minimumUpdatePeriod = _dashPlaylists$0$attr.minimumUpdatePeriod;\n  var videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);\n  var audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));\n  var vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));\n  var captions = dashPlaylists.map(function (playlist) {\n    return playlist.attributes.captionServices;\n  }).filter(Boolean);\n  var manifest = {\n    allowCache: true,\n    discontinuityStarts: [],\n    segments: [],\n    endList: true,\n    mediaGroups: (_mediaGroups = {\n      AUDIO: {},\n      VIDEO: {}\n    }, _mediaGroups['CLOSED-CAPTIONS'] = {}, _mediaGroups.SUBTITLES = {}, _mediaGroups),\n    uri: '',\n    duration: duration,\n    playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)\n  };\n\n  if (minimumUpdatePeriod >= 0) {\n    manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1000;\n  }\n\n  if (locations) {\n    manifest.locations = locations;\n  }\n\n  if (type === 'dynamic') {\n    manifest.suggestedPresentationDelay = suggestedPresentationDelay;\n  }\n\n  var isAudioOnly = manifest.playlists.length === 0;\n  var organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;\n  var organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;\n  var formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));\n  var playlistTimelineStarts = formattedPlaylists.map(function (_ref9) {\n    var timelineStarts = _ref9.timelineStarts;\n    return timelineStarts;\n  });\n  manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);\n  addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);\n\n  if (organizedAudioGroup) {\n    manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;\n  }\n\n  if (organizedVttGroup) {\n    manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;\n  }\n\n  if (captions.length) {\n    manifest.mediaGroups['CLOSED-CAPTIONS'].cc = organizeCaptionServices(captions);\n  }\n\n  if (previousManifest) {\n    return positionManifestOnTimeline({\n      oldManifest: previousManifest,\n      newManifest: manifest\n    });\n  }\n\n  return manifest;\n};\n\n/**\n * Calculates the R (repetition) value for a live stream (for the final segment\n * in a manifest where the r value is negative 1)\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {number} time\n *        current time (typically the total time up until the final segment)\n * @param {number} duration\n *        duration property for the given <S />\n *\n * @return {number}\n *        R value to reach the end of the given period\n */\nvar getLiveRValue = function getLiveRValue(attributes, time, duration) {\n  var NOW = attributes.NOW,\n      clientOffset = attributes.clientOffset,\n      availabilityStartTime = attributes.availabilityStartTime,\n      _attributes$timescale = attributes.timescale,\n      timescale = _attributes$timescale === void 0 ? 1 : _attributes$timescale,\n      _attributes$periodSta = attributes.periodStart,\n      periodStart = _attributes$periodSta === void 0 ? 0 : _attributes$periodSta,\n      _attributes$minimumUp = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp === void 0 ? 0 : _attributes$minimumUp;\n  var now = (NOW + clientOffset) / 1000;\n  var periodStartWC = availabilityStartTime + periodStart;\n  var periodEndWC = now + minimumUpdatePeriod;\n  var periodDuration = periodEndWC - periodStartWC;\n  return Math.ceil((periodDuration * timescale - time) / duration);\n};\n/**\n * Uses information provided by SegmentTemplate.SegmentTimeline to determine segment\n * timing and duration\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\n\nvar parseByTimeline = function parseByTimeline(attributes, segmentTimeline) {\n  var type = attributes.type,\n      _attributes$minimumUp2 = attributes.minimumUpdatePeriod,\n      minimumUpdatePeriod = _attributes$minimumUp2 === void 0 ? 0 : _attributes$minimumUp2,\n      _attributes$media = attributes.media,\n      media = _attributes$media === void 0 ? '' : _attributes$media,\n      sourceDuration = attributes.sourceDuration,\n      _attributes$timescale2 = attributes.timescale,\n      timescale = _attributes$timescale2 === void 0 ? 1 : _attributes$timescale2,\n      _attributes$startNumb = attributes.startNumber,\n      startNumber = _attributes$startNumb === void 0 ? 1 : _attributes$startNumb,\n      timeline = attributes.periodStart;\n  var segments = [];\n  var time = -1;\n\n  for (var sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {\n    var S = segmentTimeline[sIndex];\n    var duration = S.d;\n    var repeat = S.r || 0;\n    var segmentTime = S.t || 0;\n\n    if (time < 0) {\n      // first segment\n      time = segmentTime;\n    }\n\n    if (segmentTime && segmentTime > time) {\n      // discontinuity\n      // TODO: How to handle this type of discontinuity\n      // timeline++ here would treat it like HLS discontuity and content would\n      // get appended without gap\n      // E.G.\n      //  <S t=\"0\" d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S d=\"1\" />\n      //  <S t=\"5\" d=\"1\" />\n      // would have $Time$ values of [0, 1, 2, 5]\n      // should this be appened at time positions [0, 1, 2, 3],(#EXT-X-DISCONTINUITY)\n      // or [0, 1, 2, gap, gap, 5]? (#EXT-X-GAP)\n      // does the value of sourceDuration consider this when calculating arbitrary\n      // negative @r repeat value?\n      // E.G. Same elements as above with this added at the end\n      //  <S d=\"1\" r=\"-1\" />\n      //  with a sourceDuration of 10\n      // Would the 2 gaps be included in the time duration calculations resulting in\n      // 8 segments with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9] or 10 segments\n      // with $Time$ values of [0, 1, 2, 5, 6, 7, 8, 9, 10, 11] ?\n      time = segmentTime;\n    }\n\n    var count = void 0;\n\n    if (repeat < 0) {\n      var nextS = sIndex + 1;\n\n      if (nextS === segmentTimeline.length) {\n        // last segment\n        if (type === 'dynamic' && minimumUpdatePeriod > 0 && media.indexOf('$Number$') > 0) {\n          count = getLiveRValue(attributes, time, duration);\n        } else {\n          // TODO: This may be incorrect depending on conclusion of TODO above\n          count = (sourceDuration * timescale - time) / duration;\n        }\n      } else {\n        count = (segmentTimeline[nextS].t - time) / duration;\n      }\n    } else {\n      count = repeat + 1;\n    }\n\n    var end = startNumber + segments.length + count;\n    var number = startNumber + segments.length;\n\n    while (number < end) {\n      segments.push({\n        number: number,\n        duration: duration / timescale,\n        time: time,\n        timeline: timeline\n      });\n      time += duration;\n      number++;\n    }\n  }\n\n  return segments;\n};\n\nvar identifierPattern = /\\$([A-z]*)(?:(%0)([0-9]+)d)?\\$/g;\n/**\n * Replaces template identifiers with corresponding values. To be used as the callback\n * for String.prototype.replace\n *\n * @name replaceCallback\n * @function\n * @param {string} match\n *        Entire match of identifier\n * @param {string} identifier\n *        Name of matched identifier\n * @param {string} format\n *        Format tag string. Its presence indicates that padding is expected\n * @param {string} width\n *        Desired length of the replaced value. Values less than this width shall be left\n *        zero padded\n * @return {string}\n *         Replacement for the matched identifier\n */\n\n/**\n * Returns a function to be used as a callback for String.prototype.replace to replace\n * template identifiers\n *\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {replaceCallback}\n *         Callback to be used with String.prototype.replace to replace identifiers\n */\n\nvar identifierReplacement = function identifierReplacement(values) {\n  return function (match, identifier, format, width) {\n    if (match === '$$') {\n      // escape sequence\n      return '$';\n    }\n\n    if (typeof values[identifier] === 'undefined') {\n      return match;\n    }\n\n    var value = '' + values[identifier];\n\n    if (identifier === 'RepresentationID') {\n      // Format tag shall not be present with RepresentationID\n      return value;\n    }\n\n    if (!format) {\n      width = 1;\n    } else {\n      width = parseInt(width, 10);\n    }\n\n    if (value.length >= width) {\n      return value;\n    }\n\n    return \"\" + new Array(width - value.length + 1).join('0') + value;\n  };\n};\n/**\n * Constructs a segment url from a template string\n *\n * @param {string} url\n *        Template string to construct url from\n * @param {Obect} values\n *        Object containing values that shall be used to replace known identifiers\n * @param {number} values.RepresentationID\n *        Value of the Representation@id attribute\n * @param {number} values.Number\n *        Number of the corresponding segment\n * @param {number} values.Bandwidth\n *        Value of the Representation@bandwidth attribute.\n * @param {number} values.Time\n *        Timestamp value of the corresponding segment\n * @return {string}\n *         Segment url with identifiers replaced\n */\n\nvar constructTemplateUrl = function constructTemplateUrl(url, values) {\n  return url.replace(identifierPattern, identifierReplacement(values));\n};\n/**\n * Generates a list of objects containing timing and duration information about each\n * segment needed to generate segment uris and the complete segment object\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {{number: number, duration: number, time: number, timeline: number}[]}\n *         List of Objects with segment timing and duration info\n */\n\nvar parseTemplateInfo = function parseTemplateInfo(attributes, segmentTimeline) {\n  if (!attributes.duration && !segmentTimeline) {\n    // if neither @duration or SegmentTimeline are present, then there shall be exactly\n    // one media segment\n    return [{\n      number: attributes.startNumber || 1,\n      duration: attributes.sourceDuration,\n      time: 0,\n      timeline: attributes.periodStart\n    }];\n  }\n\n  if (attributes.duration) {\n    return parseByDuration(attributes);\n  }\n\n  return parseByTimeline(attributes, segmentTimeline);\n};\n/**\n * Generates a list of segments using information provided by the SegmentTemplate element\n *\n * @param {Object} attributes\n *        Object containing all inherited attributes from parent elements with attribute\n *        names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object[]}\n *         List of segment objects\n */\n\nvar segmentsFromTemplate = function segmentsFromTemplate(attributes, segmentTimeline) {\n  var templateValues = {\n    RepresentationID: attributes.id,\n    Bandwidth: attributes.bandwidth || 0\n  };\n  var _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {\n    sourceURL: '',\n    range: ''\n  } : _attributes$initializ;\n  var mapSegment = urlTypeToSegment({\n    baseUrl: attributes.baseUrl,\n    source: constructTemplateUrl(initialization.sourceURL, templateValues),\n    range: initialization.range\n  });\n  var segments = parseTemplateInfo(attributes, segmentTimeline);\n  return segments.map(function (segment) {\n    templateValues.Number = segment.number;\n    templateValues.Time = segment.time;\n    var uri = constructTemplateUrl(attributes.media || '', templateValues); // See DASH spec section 5.3.9.2.2\n    // - if timescale isn't present on any level, default to 1.\n\n    var timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n    var presentationTimeOffset = attributes.presentationTimeOffset || 0;\n    var presentationTime = // Even if the @t attribute is not specified for the segment, segment.time is\n    // calculated in mpd-parser prior to this, so it's assumed to be available.\n    attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;\n    var map = {\n      uri: uri,\n      timeline: segment.timeline,\n      duration: segment.duration,\n      resolvedUri: resolveUrl(attributes.baseUrl || '', uri),\n      map: mapSegment,\n      number: segment.number,\n      presentationTime: presentationTime\n    };\n    return map;\n  });\n};\n\n/**\n * Converts a <SegmentUrl> (of type URLType from the DASH spec 5.3.9.2 Table 14)\n * to an object that matches the output of a segment in videojs/mpd-parser\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object} segmentUrl\n *   <SegmentURL> node to translate into a segment object\n * @return {Object} translated segment object\n */\n\nvar SegmentURLToSegmentObject = function SegmentURLToSegmentObject(attributes, segmentUrl) {\n  var baseUrl = attributes.baseUrl,\n      _attributes$initializ = attributes.initialization,\n      initialization = _attributes$initializ === void 0 ? {} : _attributes$initializ;\n  var initSegment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: initialization.sourceURL,\n    range: initialization.range\n  });\n  var segment = urlTypeToSegment({\n    baseUrl: baseUrl,\n    source: segmentUrl.media,\n    range: segmentUrl.mediaRange\n  });\n  segment.map = initSegment;\n  return segment;\n};\n/**\n * Generates a list of segments using information provided by the SegmentList element\n * SegmentList (DASH SPEC Section 5.3.9.3.2) contains a set of <SegmentURL> nodes.  Each\n * node should be translated into segment.\n *\n * @param {Object} attributes\n *   Object containing all inherited attributes from parent elements with attribute\n *   names as keys\n * @param {Object[]|undefined} segmentTimeline\n *        List of objects representing the attributes of each S element contained within\n *        the SegmentTimeline element\n * @return {Object.<Array>} list of segments\n */\n\n\nvar segmentsFromList = function segmentsFromList(attributes, segmentTimeline) {\n  var duration = attributes.duration,\n      _attributes$segmentUr = attributes.segmentUrls,\n      segmentUrls = _attributes$segmentUr === void 0 ? [] : _attributes$segmentUr,\n      periodStart = attributes.periodStart; // Per spec (5.3.9.2.1) no way to determine segment duration OR\n  // if both SegmentTimeline and @duration are defined, it is outside of spec.\n\n  if (!duration && !segmentTimeline || duration && segmentTimeline) {\n    throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);\n  }\n\n  var segmentUrlMap = segmentUrls.map(function (segmentUrlObject) {\n    return SegmentURLToSegmentObject(attributes, segmentUrlObject);\n  });\n  var segmentTimeInfo;\n\n  if (duration) {\n    segmentTimeInfo = parseByDuration(attributes);\n  }\n\n  if (segmentTimeline) {\n    segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);\n  }\n\n  var segments = segmentTimeInfo.map(function (segmentTime, index) {\n    if (segmentUrlMap[index]) {\n      var segment = segmentUrlMap[index]; // See DASH spec section 5.3.9.2.2\n      // - if timescale isn't present on any level, default to 1.\n\n      var timescale = attributes.timescale || 1; // - if presentationTimeOffset isn't present on any level, default to 0\n\n      var presentationTimeOffset = attributes.presentationTimeOffset || 0;\n      segment.timeline = segmentTime.timeline;\n      segment.duration = segmentTime.duration;\n      segment.number = segmentTime.number;\n      segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;\n      return segment;\n    } // Since we're mapping we should get rid of any blank segments (in case\n    // the given SegmentTimeline is handling for more elements than we have\n    // SegmentURLs for).\n\n  }).filter(function (segment) {\n    return segment;\n  });\n  return segments;\n};\n\nvar generateSegments = function generateSegments(_ref) {\n  var attributes = _ref.attributes,\n      segmentInfo = _ref.segmentInfo;\n  var segmentAttributes;\n  var segmentsFn;\n\n  if (segmentInfo.template) {\n    segmentsFn = segmentsFromTemplate;\n    segmentAttributes = merge(attributes, segmentInfo.template);\n  } else if (segmentInfo.base) {\n    segmentsFn = segmentsFromBase;\n    segmentAttributes = merge(attributes, segmentInfo.base);\n  } else if (segmentInfo.list) {\n    segmentsFn = segmentsFromList;\n    segmentAttributes = merge(attributes, segmentInfo.list);\n  }\n\n  var segmentsInfo = {\n    attributes: attributes\n  };\n\n  if (!segmentsFn) {\n    return segmentsInfo;\n  }\n\n  var segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline); // The @duration attribute will be used to determin the playlist's targetDuration which\n  // must be in seconds. Since we've generated the segment list, we no longer need\n  // @duration to be in @timescale units, so we can convert it here.\n\n  if (segmentAttributes.duration) {\n    var _segmentAttributes = segmentAttributes,\n        duration = _segmentAttributes.duration,\n        _segmentAttributes$ti = _segmentAttributes.timescale,\n        timescale = _segmentAttributes$ti === void 0 ? 1 : _segmentAttributes$ti;\n    segmentAttributes.duration = duration / timescale;\n  } else if (segments.length) {\n    // if there is no @duration attribute, use the largest segment duration as\n    // as target duration\n    segmentAttributes.duration = segments.reduce(function (max, segment) {\n      return Math.max(max, Math.ceil(segment.duration));\n    }, 0);\n  } else {\n    segmentAttributes.duration = 0;\n  }\n\n  segmentsInfo.attributes = segmentAttributes;\n  segmentsInfo.segments = segments; // This is a sidx box without actual segment information\n\n  if (segmentInfo.base && segmentAttributes.indexRange) {\n    segmentsInfo.sidx = segments[0];\n    segmentsInfo.segments = [];\n  }\n\n  return segmentsInfo;\n};\nvar toPlaylists = function toPlaylists(representations) {\n  return representations.map(generateSegments);\n};\n\nvar findChildren = function findChildren(element, name) {\n  return from(element.childNodes).filter(function (_ref) {\n    var tagName = _ref.tagName;\n    return tagName === name;\n  });\n};\nvar getContent = function getContent(element) {\n  return element.textContent.trim();\n};\n\n/**\n * Converts the provided string that may contain a division operation to a number.\n *\n * @param {string} value - the provided string value\n *\n * @return {number} the parsed string value\n */\nvar parseDivisionValue = function parseDivisionValue(value) {\n  return parseFloat(value.split('/').reduce(function (prev, current) {\n    return prev / current;\n  }));\n};\n\nvar parseDuration = function parseDuration(str) {\n  var SECONDS_IN_YEAR = 365 * 24 * 60 * 60;\n  var SECONDS_IN_MONTH = 30 * 24 * 60 * 60;\n  var SECONDS_IN_DAY = 24 * 60 * 60;\n  var SECONDS_IN_HOUR = 60 * 60;\n  var SECONDS_IN_MIN = 60; // P10Y10M10DT10H10M10.1S\n\n  var durationRegex = /P(?:(\\d*)Y)?(?:(\\d*)M)?(?:(\\d*)D)?(?:T(?:(\\d*)H)?(?:(\\d*)M)?(?:([\\d.]*)S)?)?/;\n  var match = durationRegex.exec(str);\n\n  if (!match) {\n    return 0;\n  }\n\n  var _match$slice = match.slice(1),\n      year = _match$slice[0],\n      month = _match$slice[1],\n      day = _match$slice[2],\n      hour = _match$slice[3],\n      minute = _match$slice[4],\n      second = _match$slice[5];\n\n  return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);\n};\nvar parseDate = function parseDate(str) {\n  // Date format without timezone according to ISO 8601\n  // YYY-MM-DDThh:mm:ss.ssssss\n  var dateRegex = /^\\d+-\\d+-\\d+T\\d+:\\d+:\\d+(\\.\\d+)?$/; // If the date string does not specifiy a timezone, we must specifiy UTC. This is\n  // expressed by ending with 'Z'\n\n  if (dateRegex.test(str)) {\n    str += 'Z';\n  }\n\n  return Date.parse(str);\n};\n\nvar parsers = {\n  /**\n   * Specifies the duration of the entire Media Presentation. Format is a duration string\n   * as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  mediaPresentationDuration: function mediaPresentationDuration(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the Segment availability start time for all Segments referred to in this\n   * MPD. For a dynamic manifest, it specifies the anchor for the earliest availability\n   * time. Format is a date string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The date as seconds from unix epoch\n   */\n  availabilityStartTime: function availabilityStartTime(value) {\n    return parseDate(value) / 1000;\n  },\n\n  /**\n   * Specifies the smallest period between potential changes to the MPD. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  minimumUpdatePeriod: function minimumUpdatePeriod(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the suggested presentation delay. Format is a\n   * duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  suggestedPresentationDelay: function suggestedPresentationDelay(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * specifices the type of mpd. Can be either \"static\" or \"dynamic\"\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   *\n   * @return {string}\n   *         The type as a string\n   */\n  type: function type(value) {\n    return value;\n  },\n\n  /**\n   * Specifies the duration of the smallest time shifting buffer for any Representation\n   * in the MPD. Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  timeShiftBufferDepth: function timeShiftBufferDepth(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the PeriodStart time of the Period relative to the availabilityStarttime.\n   * Format is a duration string as specified in ISO 8601\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The duration in seconds\n   */\n  start: function start(value) {\n    return parseDuration(value);\n  },\n\n  /**\n   * Specifies the width of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed width\n   */\n  width: function width(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the height of the visual presentation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed height\n   */\n  height: function height(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the bitrate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed bandwidth\n   */\n  bandwidth: function bandwidth(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the frame rate of the representation\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed frame rate\n   */\n  frameRate: function frameRate(value) {\n    return parseDivisionValue(value);\n  },\n\n  /**\n   * Specifies the number of the first Media Segment in this Representation in the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  startNumber: function startNumber(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the timescale in units per seconds\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed timescale\n   */\n  timescale: function timescale(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the presentationTimeOffset.\n   *\n   * @param {string} value\n   *        value of the attribute as a string\n   *\n   * @return {number}\n   *         The parsed presentationTimeOffset\n   */\n  presentationTimeOffset: function presentationTimeOffset(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the constant approximate Segment duration\n   * NOTE: The <Period> element also contains an @duration attribute. This duration\n   *       specifies the duration of the Period. This attribute is currently not\n   *       supported by the rest of the parser, however we still check for it to prevent\n   *       errors.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  duration: function duration(value) {\n    var parsedValue = parseInt(value, 10);\n\n    if (isNaN(parsedValue)) {\n      return parseDuration(value);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Specifies the Segment duration, in units of the value of the @timescale.\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed duration\n   */\n  d: function d(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the MPD start time, in @timescale units, the first Segment in the series\n   * starts relative to the beginning of the Period\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed time\n   */\n  t: function t(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Specifies the repeat count of the number of following contiguous Segments with the\n   * same duration expressed by the value of @d\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {number}\n   *         The parsed number\n   */\n  r: function r(value) {\n    return parseInt(value, 10);\n  },\n\n  /**\n   * Default parser for all other attributes. Acts as a no-op and just returns the value\n   * as a string\n   *\n   * @param {string} value\n   *        value of attribute as a string\n   * @return {string}\n   *         Unparsed value\n   */\n  DEFAULT: function DEFAULT(value) {\n    return value;\n  }\n};\n/**\n * Gets all the attributes and values of the provided node, parses attributes with known\n * types, and returns an object with attribute names mapped to values.\n *\n * @param {Node} el\n *        The node to parse attributes from\n * @return {Object}\n *         Object with all attributes of el parsed\n */\n\nvar parseAttributes = function parseAttributes(el) {\n  if (!(el && el.attributes)) {\n    return {};\n  }\n\n  return from(el.attributes).reduce(function (a, e) {\n    var parseFn = parsers[e.name] || parsers.DEFAULT;\n    a[e.name] = parseFn(e.value);\n    return a;\n  }, {});\n};\n\nvar keySystemsMap = {\n  'urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b': 'org.w3.clearkey',\n  'urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed': 'com.widevine.alpha',\n  'urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95': 'com.microsoft.playready',\n  'urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb': 'com.adobe.primetime'\n};\n/**\n * Builds a list of urls that is the product of the reference urls and BaseURL values\n *\n * @param {string[]} referenceUrls\n *        List of reference urls to resolve to\n * @param {Node[]} baseUrlElements\n *        List of BaseURL nodes from the mpd\n * @return {string[]}\n *         List of resolved urls\n */\n\nvar buildBaseUrls = function buildBaseUrls(referenceUrls, baseUrlElements) {\n  if (!baseUrlElements.length) {\n    return referenceUrls;\n  }\n\n  return flatten(referenceUrls.map(function (reference) {\n    return baseUrlElements.map(function (baseUrlElement) {\n      return resolveUrl(reference, getContent(baseUrlElement));\n    });\n  }));\n};\n/**\n * Contains all Segment information for its containing AdaptationSet\n *\n * @typedef {Object} SegmentInformation\n * @property {Object|undefined} template\n *           Contains the attributes for the SegmentTemplate node\n * @property {Object[]|undefined} segmentTimeline\n *           Contains a list of atrributes for each S node within the SegmentTimeline node\n * @property {Object|undefined} list\n *           Contains the attributes for the SegmentList node\n * @property {Object|undefined} base\n *           Contains the attributes for the SegmentBase node\n */\n\n/**\n * Returns all available Segment information contained within the AdaptationSet node\n *\n * @param {Node} adaptationSet\n *        The AdaptationSet node to get Segment information from\n * @return {SegmentInformation}\n *         The Segment information contained within the provided AdaptationSet\n */\n\nvar getSegmentInformation = function getSegmentInformation(adaptationSet) {\n  var segmentTemplate = findChildren(adaptationSet, 'SegmentTemplate')[0];\n  var segmentList = findChildren(adaptationSet, 'SegmentList')[0];\n  var segmentUrls = segmentList && findChildren(segmentList, 'SegmentURL').map(function (s) {\n    return merge({\n      tag: 'SegmentURL'\n    }, parseAttributes(s));\n  });\n  var segmentBase = findChildren(adaptationSet, 'SegmentBase')[0];\n  var segmentTimelineParentNode = segmentList || segmentTemplate;\n  var segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, 'SegmentTimeline')[0];\n  var segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;\n  var segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, 'Initialization')[0]; // SegmentTemplate is handled slightly differently, since it can have both\n  // @initialization and an <Initialization> node.  @initialization can be templated,\n  // while the node can have a url and range specified.  If the <SegmentTemplate> has\n  // both @initialization and an <Initialization> subelement we opt to override with\n  // the node, as this interaction is not defined in the spec.\n\n  var template = segmentTemplate && parseAttributes(segmentTemplate);\n\n  if (template && segmentInitialization) {\n    template.initialization = segmentInitialization && parseAttributes(segmentInitialization);\n  } else if (template && template.initialization) {\n    // If it is @initialization we convert it to an object since this is the format that\n    // later functions will rely on for the initialization segment.  This is only valid\n    // for <SegmentTemplate>\n    template.initialization = {\n      sourceURL: template.initialization\n    };\n  }\n\n  var segmentInfo = {\n    template: template,\n    segmentTimeline: segmentTimeline && findChildren(segmentTimeline, 'S').map(function (s) {\n      return parseAttributes(s);\n    }),\n    list: segmentList && merge(parseAttributes(segmentList), {\n      segmentUrls: segmentUrls,\n      initialization: parseAttributes(segmentInitialization)\n    }),\n    base: segmentBase && merge(parseAttributes(segmentBase), {\n      initialization: parseAttributes(segmentInitialization)\n    })\n  };\n  Object.keys(segmentInfo).forEach(function (key) {\n    if (!segmentInfo[key]) {\n      delete segmentInfo[key];\n    }\n  });\n  return segmentInfo;\n};\n/**\n * Contains Segment information and attributes needed to construct a Playlist object\n * from a Representation\n *\n * @typedef {Object} RepresentationInformation\n * @property {SegmentInformation} segmentInfo\n *           Segment information for this Representation\n * @property {Object} attributes\n *           Inherited attributes for this Representation\n */\n\n/**\n * Maps a Representation node to an object containing Segment information and attributes\n *\n * @name inheritBaseUrlsCallback\n * @function\n * @param {Node} representation\n *        Representation node from the mpd\n * @return {RepresentationInformation}\n *         Representation information needed to construct a Playlist object\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Representation nodes to\n * Segment information and attributes using inherited BaseURL nodes.\n *\n * @param {Object} adaptationSetAttributes\n *        Contains attributes inherited by the AdaptationSet\n * @param {string[]} adaptationSetBaseUrls\n *        Contains list of resolved base urls inherited by the AdaptationSet\n * @param {SegmentInformation} adaptationSetSegmentInfo\n *        Contains Segment information for the AdaptationSet\n * @return {inheritBaseUrlsCallback}\n *         Callback map function\n */\n\nvar inheritBaseUrls = function inheritBaseUrls(adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) {\n  return function (representation) {\n    var repBaseUrlElements = findChildren(representation, 'BaseURL');\n    var repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);\n    var attributes = merge(adaptationSetAttributes, parseAttributes(representation));\n    var representationSegmentInfo = getSegmentInformation(representation);\n    return repBaseUrls.map(function (baseUrl) {\n      return {\n        segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),\n        attributes: merge(attributes, {\n          baseUrl: baseUrl\n        })\n      };\n    });\n  };\n};\n/**\n * Tranforms a series of content protection nodes to\n * an object containing pssh data by key system\n *\n * @param {Node[]} contentProtectionNodes\n *        Content protection nodes\n * @return {Object}\n *        Object containing pssh data by key system\n */\n\nvar generateKeySystemInformation = function generateKeySystemInformation(contentProtectionNodes) {\n  return contentProtectionNodes.reduce(function (acc, node) {\n    var attributes = parseAttributes(node); // Although it could be argued that according to the UUID RFC spec the UUID string (a-f chars) should be generated\n    // as a lowercase string it also mentions it should be treated as case-insensitive on input. Since the key system\n    // UUIDs in the keySystemsMap are hardcoded as lowercase in the codebase there isn't any reason not to do\n    // .toLowerCase() on the input UUID string from the manifest (at least I could not think of one).\n\n    if (attributes.schemeIdUri) {\n      attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();\n    }\n\n    var keySystem = keySystemsMap[attributes.schemeIdUri];\n\n    if (keySystem) {\n      acc[keySystem] = {\n        attributes: attributes\n      };\n      var psshNode = findChildren(node, 'cenc:pssh')[0];\n\n      if (psshNode) {\n        var pssh = getContent(psshNode);\n        acc[keySystem].pssh = pssh && decodeB64ToUint8Array(pssh);\n      }\n    }\n\n    return acc;\n  }, {});\n}; // defined in ANSI_SCTE 214-1 2016\n\n\nvar parseCaptionServiceMetadata = function parseCaptionServiceMetadata(service) {\n  // 608 captions\n  if (service.schemeIdUri === 'urn:scte:dash:cc:cea-608:2015') {\n    var values = typeof service.value !== 'string' ? [] : service.value.split(';');\n    return values.map(function (value) {\n      var channel;\n      var language; // default language to value\n\n      language = value;\n\n      if (/^CC\\d=/.test(value)) {\n        var _value$split = value.split('=');\n\n        channel = _value$split[0];\n        language = _value$split[1];\n      } else if (/^CC\\d$/.test(value)) {\n        channel = value;\n      }\n\n      return {\n        channel: channel,\n        language: language\n      };\n    });\n  } else if (service.schemeIdUri === 'urn:scte:dash:cc:cea-708:2015') {\n    var _values = typeof service.value !== 'string' ? [] : service.value.split(';');\n\n    return _values.map(function (value) {\n      var flags = {\n        // service or channel number 1-63\n        'channel': undefined,\n        // language is a 3ALPHA per ISO 639.2/B\n        // field is required\n        'language': undefined,\n        // BIT 1/0 or ?\n        // default value is 1, meaning 16:9 aspect ratio, 0 is 4:3, ? is unknown\n        'aspectRatio': 1,\n        // BIT 1/0\n        // easy reader flag indicated the text is tailed to the needs of beginning readers\n        // default 0, or off\n        'easyReader': 0,\n        // BIT 1/0\n        // If 3d metadata is present (CEA-708.1) then 1\n        // default 0\n        '3D': 0\n      };\n\n      if (/=/.test(value)) {\n        var _value$split2 = value.split('='),\n            channel = _value$split2[0],\n            _value$split2$ = _value$split2[1],\n            opts = _value$split2$ === void 0 ? '' : _value$split2$;\n\n        flags.channel = channel;\n        flags.language = value;\n        opts.split(',').forEach(function (opt) {\n          var _opt$split = opt.split(':'),\n              name = _opt$split[0],\n              val = _opt$split[1];\n\n          if (name === 'lang') {\n            flags.language = val; // er for easyReadery\n          } else if (name === 'er') {\n            flags.easyReader = Number(val); // war for wide aspect ratio\n          } else if (name === 'war') {\n            flags.aspectRatio = Number(val);\n          } else if (name === '3D') {\n            flags['3D'] = Number(val);\n          }\n        });\n      } else {\n        flags.language = value;\n      }\n\n      if (flags.channel) {\n        flags.channel = 'SERVICE' + flags.channel;\n      }\n\n      return flags;\n    });\n  }\n};\n/**\n * Maps an AdaptationSet node to a list of Representation information objects\n *\n * @name toRepresentationsCallback\n * @function\n * @param {Node} adaptationSet\n *        AdaptationSet node from the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping AdaptationSet nodes to a list of\n * Representation information objects\n *\n * @param {Object} periodAttributes\n *        Contains attributes inherited by the Period\n * @param {string[]} periodBaseUrls\n *        Contains list of resolved base urls inherited by the Period\n * @param {string[]} periodSegmentInfo\n *        Contains Segment Information at the period level\n * @return {toRepresentationsCallback}\n *         Callback map function\n */\n\nvar toRepresentations = function toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo) {\n  return function (adaptationSet) {\n    var adaptationSetAttributes = parseAttributes(adaptationSet);\n    var adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, 'BaseURL'));\n    var role = findChildren(adaptationSet, 'Role')[0];\n    var roleAttributes = {\n      role: parseAttributes(role)\n    };\n    var attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);\n    var accessibility = findChildren(adaptationSet, 'Accessibility')[0];\n    var captionServices = parseCaptionServiceMetadata(parseAttributes(accessibility));\n\n    if (captionServices) {\n      attrs = merge(attrs, {\n        captionServices: captionServices\n      });\n    }\n\n    var label = findChildren(adaptationSet, 'Label')[0];\n\n    if (label && label.childNodes.length) {\n      var labelVal = label.childNodes[0].nodeValue.trim();\n      attrs = merge(attrs, {\n        label: labelVal\n      });\n    }\n\n    var contentProtection = generateKeySystemInformation(findChildren(adaptationSet, 'ContentProtection'));\n\n    if (Object.keys(contentProtection).length) {\n      attrs = merge(attrs, {\n        contentProtection: contentProtection\n      });\n    }\n\n    var segmentInfo = getSegmentInformation(adaptationSet);\n    var representations = findChildren(adaptationSet, 'Representation');\n    var adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);\n    return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));\n  };\n};\n/**\n * Contains all period information for mapping nodes onto adaptation sets.\n *\n * @typedef {Object} PeriodInformation\n * @property {Node} period.node\n *           Period node from the mpd\n * @property {Object} period.attributes\n *           Parsed period attributes from node plus any added\n */\n\n/**\n * Maps a PeriodInformation object to a list of Representation information objects for all\n * AdaptationSet nodes contained within the Period.\n *\n * @name toAdaptationSetsCallback\n * @function\n * @param {PeriodInformation} period\n *        Period object containing necessary period information\n * @param {number} periodStart\n *        Start time of the Period within the mpd\n * @return {RepresentationInformation[]}\n *         List of objects containing Representaion information\n */\n\n/**\n * Returns a callback for Array.prototype.map for mapping Period nodes to a list of\n * Representation information objects\n *\n * @param {Object} mpdAttributes\n *        Contains attributes inherited by the mpd\n * @param {string[]} mpdBaseUrls\n *        Contains list of resolved base urls inherited by the mpd\n * @return {toAdaptationSetsCallback}\n *         Callback map function\n */\n\nvar toAdaptationSets = function toAdaptationSets(mpdAttributes, mpdBaseUrls) {\n  return function (period, index) {\n    var periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, 'BaseURL'));\n    var periodAttributes = merge(mpdAttributes, {\n      periodStart: period.attributes.start\n    });\n\n    if (typeof period.attributes.duration === 'number') {\n      periodAttributes.periodDuration = period.attributes.duration;\n    }\n\n    var adaptationSets = findChildren(period.node, 'AdaptationSet');\n    var periodSegmentInfo = getSegmentInformation(period.node);\n    return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));\n  };\n};\n/**\n * Gets Period@start property for a given period.\n *\n * @param {Object} options\n *        Options object\n * @param {Object} options.attributes\n *        Period attributes\n * @param {Object} [options.priorPeriodAttributes]\n *        Prior period attributes (if prior period is available)\n * @param {string} options.mpdType\n *        The MPD@type these periods came from\n * @return {number|null}\n *         The period start, or null if it's an early available period or error\n */\n\nvar getPeriodStart = function getPeriodStart(_ref) {\n  var attributes = _ref.attributes,\n      priorPeriodAttributes = _ref.priorPeriodAttributes,\n      mpdType = _ref.mpdType;\n\n  // Summary of period start time calculation from DASH spec section 5.3.2.1\n  //\n  // A period's start is the first period's start + time elapsed after playing all\n  // prior periods to this one. Periods continue one after the other in time (without\n  // gaps) until the end of the presentation.\n  //\n  // The value of Period@start should be:\n  // 1. if Period@start is present: value of Period@start\n  // 2. if previous period exists and it has @duration: previous Period@start +\n  //    previous Period@duration\n  // 3. if this is first period and MPD@type is 'static': 0\n  // 4. in all other cases, consider the period an \"early available period\" (note: not\n  //    currently supported)\n  // (1)\n  if (typeof attributes.start === 'number') {\n    return attributes.start;\n  } // (2)\n\n\n  if (priorPeriodAttributes && typeof priorPeriodAttributes.start === 'number' && typeof priorPeriodAttributes.duration === 'number') {\n    return priorPeriodAttributes.start + priorPeriodAttributes.duration;\n  } // (3)\n\n\n  if (!priorPeriodAttributes && mpdType === 'static') {\n    return 0;\n  } // (4)\n  // There is currently no logic for calculating the Period@start value if there is\n  // no Period@start or prior Period@start and Period@duration available. This is not made\n  // explicit by the DASH interop guidelines or the DASH spec, however, since there's\n  // nothing about any other resolution strategies, it's implied. Thus, this case should\n  // be considered an early available period, or error, and null should suffice for both\n  // of those cases.\n\n\n  return null;\n};\n/**\n * Traverses the mpd xml tree to generate a list of Representation information objects\n * that have inherited attributes from parent nodes\n *\n * @param {Node} mpd\n *        The root node of the mpd\n * @param {Object} options\n *        Available options for inheritAttributes\n * @param {string} options.manifestUri\n *        The uri source of the mpd\n * @param {number} options.NOW\n *        Current time per DASH IOP.  Default is current time in ms since epoch\n * @param {number} options.clientOffset\n *        Client time difference from NOW (in milliseconds)\n * @return {RepresentationInformation[]}\n *         List of objects containing Representation information\n */\n\nvar inheritAttributes = function inheritAttributes(mpd, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$manifestUri = _options.manifestUri,\n      manifestUri = _options$manifestUri === void 0 ? '' : _options$manifestUri,\n      _options$NOW = _options.NOW,\n      NOW = _options$NOW === void 0 ? Date.now() : _options$NOW,\n      _options$clientOffset = _options.clientOffset,\n      clientOffset = _options$clientOffset === void 0 ? 0 : _options$clientOffset;\n  var periodNodes = findChildren(mpd, 'Period');\n\n  if (!periodNodes.length) {\n    throw new Error(errors.INVALID_NUMBER_OF_PERIOD);\n  }\n\n  var locations = findChildren(mpd, 'Location');\n  var mpdAttributes = parseAttributes(mpd);\n  var mpdBaseUrls = buildBaseUrls([manifestUri], findChildren(mpd, 'BaseURL')); // See DASH spec section 5.3.1.2, Semantics of MPD element. Default type to 'static'.\n\n  mpdAttributes.type = mpdAttributes.type || 'static';\n  mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;\n  mpdAttributes.NOW = NOW;\n  mpdAttributes.clientOffset = clientOffset;\n\n  if (locations.length) {\n    mpdAttributes.locations = locations.map(getContent);\n  }\n\n  var periods = []; // Since toAdaptationSets acts on individual periods right now, the simplest approach to\n  // adding properties that require looking at prior periods is to parse attributes and add\n  // missing ones before toAdaptationSets is called. If more such properties are added, it\n  // may be better to refactor toAdaptationSets.\n\n  periodNodes.forEach(function (node, index) {\n    var attributes = parseAttributes(node); // Use the last modified prior period, as it may contain added information necessary\n    // for this period.\n\n    var priorPeriod = periods[index - 1];\n    attributes.start = getPeriodStart({\n      attributes: attributes,\n      priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,\n      mpdType: mpdAttributes.type\n    });\n    periods.push({\n      node: node,\n      attributes: attributes\n    });\n  });\n  return {\n    locations: mpdAttributes.locations,\n    representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls)))\n  };\n};\n\nvar stringToMpdXml = function stringToMpdXml(manifestString) {\n  if (manifestString === '') {\n    throw new Error(errors.DASH_EMPTY_MANIFEST);\n  }\n\n  var parser = new DOMParser();\n  var xml;\n  var mpd;\n\n  try {\n    xml = parser.parseFromString(manifestString, 'application/xml');\n    mpd = xml && xml.documentElement.tagName === 'MPD' ? xml.documentElement : null;\n  } catch (e) {// ie 11 throwsw on invalid xml\n  }\n\n  if (!mpd || mpd && mpd.getElementsByTagName('parsererror').length > 0) {\n    throw new Error(errors.DASH_INVALID_XML);\n  }\n\n  return mpd;\n};\n\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} mpd\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\nvar parseUTCTimingScheme = function parseUTCTimingScheme(mpd) {\n  var UTCTimingNode = findChildren(mpd, 'UTCTiming')[0];\n\n  if (!UTCTimingNode) {\n    return null;\n  }\n\n  var attributes = parseAttributes(UTCTimingNode);\n\n  switch (attributes.schemeIdUri) {\n    case 'urn:mpeg:dash:utc:http-head:2014':\n    case 'urn:mpeg:dash:utc:http-head:2012':\n      attributes.method = 'HEAD';\n      break;\n\n    case 'urn:mpeg:dash:utc:http-xsdate:2014':\n    case 'urn:mpeg:dash:utc:http-iso:2014':\n    case 'urn:mpeg:dash:utc:http-xsdate:2012':\n    case 'urn:mpeg:dash:utc:http-iso:2012':\n      attributes.method = 'GET';\n      break;\n\n    case 'urn:mpeg:dash:utc:direct:2014':\n    case 'urn:mpeg:dash:utc:direct:2012':\n      attributes.method = 'DIRECT';\n      attributes.value = Date.parse(attributes.value);\n      break;\n\n    case 'urn:mpeg:dash:utc:http-ntp:2014':\n    case 'urn:mpeg:dash:utc:ntp:2014':\n    case 'urn:mpeg:dash:utc:sntp:2014':\n    default:\n      throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);\n  }\n\n  return attributes;\n};\n\nvar VERSION = version;\n/*\n * Given a DASH manifest string and options, parses the DASH manifest into an object in the\n * form outputed by m3u8-parser and accepted by videojs/http-streaming.\n *\n * For live DASH manifests, if `previousManifest` is provided in options, then the newly\n * parsed DASH manifest will have its media sequence and discontinuity sequence values\n * updated to reflect its position relative to the prior manifest.\n *\n * @param {string} manifestString - the DASH manifest as a string\n * @param {options} [options] - any options\n *\n * @return {Object} the manifest object\n */\n\nvar parse = function parse(manifestString, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);\n  var playlists = toPlaylists(parsedManifestInfo.representationInfo);\n  return toM3u8({\n    dashPlaylists: playlists,\n    locations: parsedManifestInfo.locations,\n    sidxMapping: options.sidxMapping,\n    previousManifest: options.previousManifest\n  });\n};\n/**\n * Parses the manifest for a UTCTiming node, returning the nodes attributes if found\n *\n * @param {string} manifestString\n *        XML string of the MPD manifest\n * @return {Object|null}\n *         Attributes of UTCTiming node specified in the manifest. Null if none found\n */\n\n\nvar parseUTCTiming = function parseUTCTiming(manifestString) {\n  return parseUTCTimingScheme(stringToMpdXml(manifestString));\n};\n\nexport { VERSION, addSidxSegmentsToPlaylist$1 as addSidxSegmentsToPlaylist, generateSidxKey, inheritAttributes, parse, parseUTCTiming, stringToMpdXml, toM3u8, toPlaylists };\n"],"names":["isObject","obj","merge","_len","arguments","length","objects","Array","_key","reduce","result","source","Object","keys","forEach","key","isArray","concat","values","o","map","k","flatten","lists","x","y","from","list","i","push","findIndex","matchingFunction","errors","urlTypeToSegment","_ref","_ref$baseUrl","baseUrl","_ref$source","_ref$range","range","_ref$indexRange","indexRange","segment","uri","resolvedUri","ranges","split","startRange","parseInt","endRange","Number","MAX_SAFE_INTEGER","byterange","offset","parseEndNumber","endNumber","isNaN","segmentRange","static","attributes","duration","_attributes$timescale","timescale","sourceDuration","periodDuration","segmentDuration","start","end","dynamic","NOW","clientOffset","availabilityStartTime","_attributes$timescale2","_attributes$periodSta","periodStart","_attributes$minimumUp","minimumUpdatePeriod","_attributes$timeShift","timeShiftBufferDepth","Infinity","now","periodStartWC","segmentCount","Math","ceil","availableStart","floor","availableEnd","max","min","parseByDuration","type","_attributes$timescale4","_segmentRange$type","segments","number","_attributes$timescale3","_attributes$startNumb","startNumber","timeline","time","toSegments","index","sectionDuration","segmentsFromBase","_attributes$initializ","initialization","_attributes$indexRang","presentationTime","_attributes$number","Error","initSegment","sourceURL","segmentTimeInfo","addSidxSegmentsToPlaylist$1","playlist","sidx","startIndex","sidxByteRange","sidxEnd","mediaReferences","references","filter","r","referenceType","endList","mediaSequence","firstOffset","reference","size","referencedSize","subsegmentDuration","endIndex","SUPPORTED_MEDIA_TYPES","TIME_FUDGE","getUniqueTimelineStarts","timelineStarts","keyFunction","acc","el","sort","a","b","getMediaGroupPlaylists","manifest","mediaGroupPlaylists","properties","group","label","playlists","updateMediaSequenceForPlaylist","_ref2","positionManifestOnTimeline","_ref5","oldManifest","newManifest","oldPlaylists","newPlaylists","_ref3","discontinuitySequence","_ref4","oldPlaylist","name","NAME","findPlaylistWithName","firstNewSegment","oldMatchingSegmentIndex","oldSegment","abs","discontinuity","discontinuityStarts","unshift","updateSequenceNumbers","generateSidxKey","mergeDiscontiguousPlaylists","id","lang","_acc$name$segments","apply","contentProtection","l","e","addSidxSegmentsToPlaylist","sidxMapping","sidxKey","sidxMatch","addSidxSegmentsToPlaylists","formatVideoPlaylist","_attributes2","AUDIO","SUBTITLES","RESOLUTION","width","height","CODECS","codecs","BANDWIDTH","bandwidth","targetDuration","frameRate","videoOnly","mimeType","contentType","audioOnly","vttOnly","_ref6","flattenMediaGroupPlaylists","mediaGroupObject","labelContents","toM3u8","_ref8","_mediaGroups","dashPlaylists","locations","_ref8$sidxMapping","previousManifest","_dashPlaylists$0$attr","suggestedPresentationDelay","videoPlaylists","audioPlaylists","vttPlaylists","captions","captionServices","Boolean","allowCache","mediaGroups","VIDEO","isAudioOnly","organizedAudioGroup","mainPlaylist","formattedPlaylists","role","value","language","roleLabel","autoselect","default","formatted","_attributes","formatAudioPlaylist","organizeAudioPlaylists","organizedVttGroup","_m3u8Attributes","m3u8Attributes","formatVttPlaylist","organizeVttPlaylists","playlistTimelineStarts","_ref9","_ref7","audio","subs","cc","svcObj","svc","service","channel","instreamId","hasOwnProperty","aspectRatio","easyReader","getLiveRValue","parseByTimeline","segmentTimeline","_attributes$minimumUp2","_attributes$media","media","sIndex","S","d","repeat","segmentTime","t","count","nextS","indexOf","identifierPattern","constructTemplateUrl","url","replace","match","identifier","format","join","identifierReplacement","segmentsFromTemplate","templateValues","RepresentationID","Bandwidth","mapSegment","parseTemplateInfo","Time","presentationTimeOffset","segmentsFromList","_attributes$segmentUr","segmentUrls","segmentUrlMap","segmentUrlObject","segmentUrl","mediaRange","SegmentURLToSegmentObject","generateSegments","segmentAttributes","segmentsFn","segmentInfo","template","base","segmentsInfo","_segmentAttributes","_segmentAttributes$ti","findChildren","element","childNodes","tagName","getContent","textContent","trim","parseDuration","str","exec","_match$slice","slice","year","month","day","hour","minute","second","parseFloat","parsers","mediaPresentationDuration","test","Date","parse","prev","current","parseDivisionValue","parsedValue","DEFAULT","parseAttributes","parseFn","keySystemsMap","buildBaseUrls","referenceUrls","baseUrlElements","baseUrlElement","getSegmentInformation","adaptationSet","segmentTemplate","segmentList","s","tag","segmentBase","segmentTimelineParentNode","segmentInitializationParentNode","segmentInitialization","toRepresentations","periodAttributes","periodBaseUrls","periodSegmentInfo","adaptationSetAttributes","adaptationSetBaseUrls","roleAttributes","attrs","accessibility","schemeIdUri","_value$split","flags","undefined","_value$split2","_value$split2$","opts","opt","_opt$split","val","labelVal","nodeValue","node","toLowerCase","keySystem","psshNode","pssh","representations","adaptationSetSegmentInfo","representation","repBaseUrlElements","repBaseUrls","representationSegmentInfo","inheritBaseUrls","toAdaptationSets","mpdAttributes","mpdBaseUrls","period","adaptationSets","stringToMpdXml","manifestString","xml","mpd","parser","DOMParser","parseFromString","documentElement","getElementsByTagName","options","parsedManifestInfo","_options","_options$manifestUri","manifestUri","_options$NOW","_options$clientOffset","periodNodes","periods","priorPeriod","priorPeriodAttributes","mpdType","getPeriodStart","representationInfo","inheritAttributes","parseUTCTiming","UTCTimingNode","method","parseUTCTimingScheme"],"sourceRoot":""}